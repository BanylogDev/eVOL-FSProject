@inherits LayoutComponentBase

<div class="app-shell">
    <header class="topbar">
        <div class="brand">
            <span class="rocket">🚀</span>
            <span class="title">eVOL</span>
        </div>
        <nav class="right-nav">
            <a href="/" class="nav-link">Home</a>
            <a href="/login" class="nav-link primary">Login</a>
        </nav>
    </header>

    <main class="content">
        @Body
    </main>

    <footer class="footer">
        <small>All rights reserved 2025 | Developed By Banylog</small>
    </footer>

    <!-- Canvas background for many moving dots/lines with cursor attraction -->
    <canvas id="network-canvas" aria-hidden="true"></canvas>
</div>

<style>
    .brand .title {
        text-transform: none;
    }

    :root {
        --bg-black: #000000;
        --accent-gold: #ffd700;
        --accent-blue: #0eb7ff;
        --muted: #d6d6d6;
        --card-border: rgba(255,215,0,0.09);
        --radius: 14px;
        font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    }

    /* global layout (no scrollbars) */
    html, body, #app {
        height: 100%;
        margin: 0;
        background: linear-gradient(180deg, #000000 0%, #03020a 60%, #000000 100%);
        overflow: hidden;
        color: var(--muted);
    }

    /* ensure canvas sits behind content */
    #network-canvas {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        pointer-events: none;
        display: block;
        opacity: 0.95;
        mix-blend-mode: screen;
    }

    /* keep topbar and other elements above canvas */
    .app-shell {
        position: relative;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
    }

    .topbar {
        position: relative;
        z-index: 30;
        height: 72px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 28px;
        background: linear-gradient(90deg, rgba(255,215,0,0.02), rgba(0,0,0,0.35));
        border-bottom: 1px solid rgba(255,215,0,0.06);
        backdrop-filter: blur(8px);
    }

    .brand {
        display: flex;
        align-items: center;
        gap: 12px;
        color: var(--accent-gold);
        font-weight: 900;
        text-transform: uppercase;
        letter-spacing: 2px;
    }

        .brand .rocket {
            font-size: 22px;
            transform: translateY(-1px);
            filter: drop-shadow(0 6px 12px rgba(255,215,0,0.06));
        }

        .brand .title {
            font-size: 22px;
        }

    /* nav right */
    .right-nav {
        display: flex;
        gap: 12px;
        align-items: center;
        z-index: 31;
    }

    .nav-link {
        color: var(--muted);
        text-decoration: none;
        padding: 8px 14px;
        border-radius: 10px;
        transition: transform .18s ease, box-shadow .18s ease, color .18s ease, background .18s ease;
        font-weight: 700;
    }

        .nav-link:hover {
            transform: translateY(-3px) scale(1.02);
            color: #fff;
            box-shadow: 0 8px 30px rgba(14,183,255,0.06);
            background: rgba(255,255,255,0.02);
        }

        .nav-link.primary {
            color: var(--accent-blue);
            border: 1px solid rgba(14,183,255,0.12);
            background: linear-gradient(90deg, rgba(14,183,255,0.06), rgba(14,183,255,0.02));
        }

    /* content sits above canvas */
    .content {
        flex: 1;
        position: relative;
        z-index: 10;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 36px;
    }

    /* footer */
    .footer {
        position: relative;
        z-index: 20;
        height: 52px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: rgba(255,255,255,0.28);
        font-size: 13px;
        border-top: 1px solid rgba(255,215,0,0.03);
        background: linear-gradient(180deg, transparent, rgba(0,0,0,0.2));
    }

    /* subtle hover/glow enhancements for controls within pages (keeps existing classes intact) */
    .btn, .input, .card, .feature-box {
        transition: transform .22s cubic-bezier(.2,.9,.2,1), box-shadow .22s ease, border-color .18s ease;
    }

        /* buttons: hover and focus */
        .btn:hover, .btn:focus {
            transform: translateY(-4px);
            box-shadow: 0 18px 50px rgba(0,0,0,0.6), 0 6px 30px rgba(255,183,50,0.06);
        }

        /* cards: subtle lift on hover */
        .card:hover {
            transform: translateY(-6px);
            box-shadow: 0 28px 70px rgba(0,0,0,0.8);
        }

        /* inputs: stronger focus outline */
        .input:focus {
            box-shadow: 0 10px 30px rgba(14,183,255,0.08);
            border-color: rgba(14,183,255,0.18);
        }

    /* responsive safety (no media here to avoid razor parsing if inlined) */
</style>

<script>
    if (!window.__networkCanvasInit) {
      window.__networkCanvasInit = true;

      (function() {
        const canvas = document.getElementById('network-canvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d', { alpha: true });

        // state
        let DPR = Math.max(1, window.devicePixelRatio || 1);
        let w = 0;
        let h = 0;
        let nodes = [];
        let NODE_COUNT = 0;
        const NODE_RADIUS = 2.1;
        const BLUE = 'rgba(14,183,255,';
        const GOLD = 'rgba(255,215,0,';
        const BACK_ALPHA = 0.92;
        const mouse = { x: 0, y: 0, active: false };

        function rand(min, max) { return Math.random() * (max - min) + min; }

        // deterministic canvas sizing that avoids fractional scaling zoom issues
        function resizeCanvas() {
          DPR = Math.max(1, window.devicePixelRatio || 1);
          w = window.innerWidth;
          h = window.innerHeight;

          // set CSS display size
          canvas.style.width = w + 'px';
          canvas.style.height = h + 'px';

          // set actual pixel buffer using integers to avoid subpixel scaling artifacts
          const pixelW = Math.max(1, Math.round(w * DPR));
          const pixelH = Math.max(1, Math.round(h * DPR));
          if (canvas.width !== pixelW || canvas.height !== pixelH) {
            canvas.width = pixelW;
            canvas.height = pixelH;
          }

          // Reset transform then scale exactly once for DPR
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.scale(DPR, DPR);

          // recalc constants and nodes count based on new size
          const area = w * h;
          const base = Math.max(80, Math.round(area / 90000) * 36);
          NODE_COUNT = base;
          MAX_LINK_DISTANCE = Math.min(w, h) / 6;

          // ensure nodes array matches NODE_COUNT but do not re-create if already similar size
          if (nodes.length < NODE_COUNT) {
            const add = NODE_COUNT - nodes.length;
            for (let i = 0; i < add; i++) {
              nodes.push({
                x: rand(0, w),
                y: rand(0, h),
                vx: rand(-0.14, 0.14),
                vy: rand(-0.14, 0.14),
                r: NODE_RADIUS * (0.85 + Math.random() * 0.7),
                hue: Math.random() > 0.985 ? 'gold' : 'blue',
                life: rand(0, 400)
              });
            }
          } else if (nodes.length > NODE_COUNT * 1.4) {
            // trim down if drastically larger
            nodes.splice(0, nodes.length - NODE_COUNT);
          }

          // store latest sizes for the draw loop
          lastResizeAt = performance.now();
        }

        // initialize nodes
        function initNodes() {
          nodes = [];
          const area = window.innerWidth * window.innerHeight;
          const base = Math.max(80, Math.round(area / 90000) * 36);
          NODE_COUNT = base;
          for (let i = 0; i < NODE_COUNT; i++) {
            nodes.push({
              x: rand(0, window.innerWidth),
              y: rand(0, window.innerHeight),
              vx: rand(-0.14, 0.14),
              vy: rand(-0.14, 0.14),
              r: NODE_RADIUS * (0.85 + Math.random() * 0.7),
              hue: Math.random() > 0.985 ? 'gold' : 'blue',
              life: rand(0, 400)
            });
          }
        }

        // guard constants that change on resize
        let MAX_LINK_DISTANCE = Math.min(window.innerWidth, window.innerHeight) / 6;
        let lastResizeAt = 0;

        // single-run initialization
        initNodes();
        resizeCanvas();

        // handle high-DPI change and window resize
        window.addEventListener('resize', () => {
          // debounce a tiny bit to avoid thrash
          clearTimeout(window.__networkCanvasResizeTimer);
          window.__networkCanvasResizeTimer = setTimeout(resizeCanvas, 80);
        }, { passive: true });

        // expose a manual resize (useful if Blazor re-renders layout)
        window.__networkCanvasResize = resizeCanvas;

        // Blazor emits navigation events that do not reload page; ensure canvas stays correctly sized.
        // Listen for popstate and pushstate style navigation (History API) as an extra precaution.
        window.addEventListener('popstate', () => { resizeCanvas(); }, { passive: true });
        const origPush = history.pushState;
        history.pushState = function() {
          origPush.apply(this, arguments);
          // schedule a resize after router updates DOM
          setTimeout(resizeCanvas, 60);
        };

        // mouse tracking
        window.addEventListener('mousemove', function(e) {
          mouse.x = e.clientX;
          mouse.y = e.clientY;
          mouse.active = true;
        }, { passive: true });
        window.addEventListener('mouseleave', function() { mouse.active = false; }, { passive: true });

        // detect if pointer is over UI to disable attraction
        function cursorOverUI(x, y) {
          const el = document.elementFromPoint(x, y);
          if (!el) return false;
          let node = el;
          while (node && node !== document.body) {
            const cls = node.className;
            if (typeof cls === 'string' && (cls.indexOf('card') !== -1 || cls.indexOf('auth-card') !== -1 || cls.indexOf('home-panel') !== -1 || cls.indexOf('feature-box') !== -1)) {
              return true;
            }
            node = node.parentElement;
          }
          return false;
        }

        // physics update
        function applyForces(n, dt) {
          n.vx *= 0.992;
          n.vy *= 0.992;

          if (mouse.active && !cursorOverUI(mouse.x, mouse.y)) {
            const dx = mouse.x - n.x;
            const dy = mouse.y - n.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const CLOSE_RADIUS = Math.min(260, Math.max(80, Math.min(window.innerWidth, window.innerHeight) / 7));
            if (dist > 1 && dist < CLOSE_RADIUS) {
              const force = (1 - dist / CLOSE_RADIUS) * 0.018;
              n.vx += dx * force * 0.012;
              n.vy += dy * force * 0.012;
            }
          } else {
            n.vx += Math.sin(n.life * 0.006) * 0.0012;
            n.vy += Math.cos(n.life * 0.006) * 0.0012;
          }

          n.x += n.vx * dt * 1.25;
          n.y += n.vy * dt * 1.25;

          if (n.x < -40) n.x = window.innerWidth + 40;
          if (n.x > window.innerWidth + 40) n.x = -40;
          if (n.y < -40) n.y = window.innerHeight + 40;
          if (n.y > window.innerHeight + 40) n.y = -40;

          n.life += 0.6;
        }

        // drawing loop
        let last = performance.now();
        function frame(now) {
          const dt = Math.min(1.6, (now - last) / 16);
          last = now;

          // clear using CSS pixel dimensions (ctx is already scaled for DPR)
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = 'rgba(0,0,0,' + (1 - BACK_ALPHA) + ')';
          ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

          // update & draw nodes
          for (let i = 0; i < nodes.length; i++) {
            const n = nodes[i];
            applyForces(n, dt);

            const alpha = 0.46 + Math.sin(n.life * 0.016) * 0.14;
            if (n.hue === 'gold') {
              ctx.fillStyle = GOLD + (0.78 * alpha) + ')';
              ctx.shadowColor = 'rgba(255,215,0,0.11)';
              ctx.shadowBlur = 12;
            } else {
              ctx.fillStyle = BLUE + (0.78 * alpha) + ')';
              ctx.shadowColor = 'rgba(14,183,255,0.08)';
              ctx.shadowBlur = 10;
            }
            ctx.beginPath();
            ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
          }

          // draw lines between neighbors
          ctx.lineWidth = 0.9;
          MAX_LINK_DISTANCE = Math.min(window.innerWidth, window.innerHeight) / 6;
          for (let i = 0; i < nodes.length; i++) {
            const a = nodes[i];
            const neighborLimit = 12;
            for (let j = i + 1; j < i + 1 + neighborLimit && j < nodes.length; j++) {
              const b = nodes[j];
              const dx = a.x - b.x;
              const dy = a.y - b.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < MAX_LINK_DISTANCE) {
                const lineAlpha = (1 - dist / MAX_LINK_DISTANCE) * 0.14;
                if (a.hue === 'gold' || b.hue === 'gold') {
                  ctx.strokeStyle = 'rgba(255,215,0,' + (lineAlpha * 0.55) + ')';
                } else {
                  ctx.strokeStyle = 'rgba(14,183,255,' + (lineAlpha * 0.95) + ')';
                }
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.stroke();
              }
            }

            // cursor lines when very close
            if (mouse.active && !cursorOverUI(mouse.x, mouse.y)) {
              const mdx = a.x - mouse.x;
              const mdy = a.y - mouse.y;
              const md = Math.sqrt(mdx * mdx + mdy * mdy);
              const CURSOR_LINK_RADIUS = Math.min(220, Math.max(80, Math.min(window.innerWidth, window.innerHeight) / 8));
              if (md < CURSOR_LINK_RADIUS) {
                const la = (1 - md / CURSOR_LINK_RADIUS) * 0.24;
                ctx.strokeStyle = 'rgba(255,215,0,' + (la * 0.78) + ')';
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(mouse.x, mouse.y);
                ctx.stroke();
              }
            }
          }

          requestAnimationFrame(frame);
        }

        requestAnimationFrame(frame);

        // adaptive FPS adjustments (keeps behavior stable)
        let fpsSamples = [];
        setInterval(() => {
          const now = performance.now();
          fpsSamples.push(now);
          while (fpsSamples.length > 30) fpsSamples.shift();
          if (fpsSamples.length >= 10) {
            const dt = (fpsSamples[fpsSamples.length - 1] - fpsSamples[0]) / (fpsSamples.length - 1);
            const fps = 1000 / dt;
            if (fps < 30 && nodes.length > 60) {
              nodes.splice(0, Math.max(4, Math.round(nodes.length * 0.05)));
            }
            if (fps > 50 && nodes.length < Math.max(80, NODE_COUNT)) {
              const target = Math.min(NODE_COUNT, nodes.length + 12);
              while (nodes.length < target) {
                nodes.push({
                  x: rand(0, window.innerWidth),
                  y: rand(0, window.innerHeight),
                  vx: rand(-0.14, 0.14),
                  vy: rand(-0.14, 0.14),
                  r: NODE_RADIUS * (0.85 + Math.random() * 0.7),
                  hue: Math.random() > 0.985 ? 'gold' : 'blue',
                  life: rand(0, 400)
                });
              }
            }
          }
        }, 1600);

      })();
    }
</script>

